---
alwaysApply: true
---

# Development Rules for my-app

## Component Development Standards

### 1. TypeScript Requirement

- **ALL components MUST be written in TypeScript** (.tsx for React components, .ts for utilities)
- Never use JavaScript (.js/.jsx) files for new components
- Always define proper TypeScript types and interfaces for props, state, and function parameters
- Use strict TypeScript typing - avoid `any` types unless absolutely necessary
- Leverage TypeScript's type inference where appropriate

### 2. Next.js Framework

- **ALL components MUST be developed using Next.js conventions**
- Use Next.js App Router structure (components in `src/app/` or `src/components/`)
- Leverage Next.js features:
  - Server Components by default (use 'use client' directive only when needed)
  - Next.js Image component for images
  - Next.js Link component for navigation
  - File-based routing structure
- Follow Next.js best practices for data fetching, caching, and rendering

### 3. Material Design System

- **ALL components MUST follow Material Design principles**
- Use Material UI (@mui/material) components and patterns
- Import Material UI components from `@mui/material`
- Use the MuiThemeProvider wrapper for theme consistency
- Follow Material Design guidelines for:
  - Typography scale
  - Color system
  - Spacing and layout (8dp grid system)
  - Component elevation and shadows
  - Motion and transitions
- Ensure components are accessible and follow Material Design accessibility standards

### 4. Component Structure

- Components should be:
  - Functional components using TypeScript
  - Properly typed with interfaces for props
  - Located in appropriate directories (`src/components/` for reusable components, `src/app/` for page components)
  - Named using PascalCase (e.g., `Button.tsx`, `UserProfile.tsx`)
  - Each component should have its own directory structure:
    ```
    ComponentName/
      ComponentName.tsx (with types defined at the top of the file)
      styles/
        ComponentName.module.scss
    ```
- **Types MUST be defined at the top of the component file** - do NOT create separate `types.ts` files
- **Do NOT create `index.ts` files** - they increase bundle size unnecessarily. Next.js automatically resolves imports to `ComponentName.tsx`
- Only define props that are actually used - remove unnecessary props to keep components simple
- Types should be defined as interfaces at the top of the component file, before the component implementation

### 5. Styling with SCSS

- **ALL components MUST use SCSS for styling**
- Each component MUST have its own SCSS module file located in `styles/` subdirectory
- SCSS files should be named: `ComponentName.module.scss`
- Use CSS Modules for scoped styling (import as `styles` object)
- SCSS files should be placed in `componentName/styles/` directory
- Follow Material Design spacing and design tokens in SCSS
- Use SCSS features: variables, nesting, mixins, and media queries
- **Prefer SCSS modules over inline `sx` props** - use `sx` only when absolutely necessary
- Use `!important` when needed to override Material UI default styles
- Use CSS variables from `globals.css` for colors and design tokens (e.g., `var(--color-secondary)`, `var(--color-text-primary)`)
- Example structure:

  ```typescript
  // ComponentName.tsx
  import styles from "./styles/ComponentName.module.scss";

  export default function ComponentName() {
    return <div className={styles.container}>...</div>;
  }
  ```

### 6. CSS Variables and Global Styles

- **Define reusable design tokens in `globals.css`** as CSS variables
- Use CSS variables for colors, spacing, and other design tokens (e.g., `var(--color-secondary)`, `var(--color-text-primary)`)
- Common CSS variables should include:
  - Color variables: `--color-secondary`, `--color-text-primary`, `--color-text-secondary`
  - Border radius: `--border-radius-icon`, `--border-radius-full`
  - Other design tokens as needed
- Reference CSS variables in SCSS modules: `color: var(--color-text-primary);`
- Keep global styles minimal - prefer component-scoped SCSS modules

### 7. Code Quality

- Use ESLint configuration provided by Next.js
- Follow React best practices (hooks, component composition)
- Write clean, maintainable, and well-documented code
- Use meaningful variable and function names

### 8. Package Management

- **ALWAYS use bun or yarn for package management** (prefer bun if available, fallback to yarn)
- Never use npm directly for installing packages
- Use `bun add <package>` or `yarn add <package>` for dependencies
- Use `bun add -d <package>` or `yarn add -D <package>` for dev dependencies
- Use `bun install` or `yarn install` to install all dependencies

### 9. Navigation and Routing

- **ALWAYS use Next.js App Router** for navigation and routing
- Use `next/link` Link component for client-side navigation
- Use `useRouter()` from `next/navigation` for programmatic navigation
- For dynamic routes, use `[param]` folder structure (e.g., `app/user/[id]/page.tsx`)
- Handle loading and error states in dynamic route pages
- Prevent event propagation when nested interactive elements exist:
  ```typescript
  const handleAction = (e: React.MouseEvent<HTMLButtonElement>): void => {
    e.preventDefault()
    e.stopPropagation()
    // action logic
  }
  ```
- When making entire cards/components clickable, use `component={Link}` prop on Material UI Card/Paper components
- Avoid nested Link components - use event handlers with router.push() for nested buttons

### 10. Data Management and Utilities

- **ALWAYS create centralized data/utility files** in `src/lib/` directory
- Group related data and functions together (e.g., `src/lib/users.ts` for user-related data and functions)
- Export data arrays/objects and utility functions from lib files
- Define types inline in lib files or import from component files if needed
- **Form Utilities:**
  - Create reusable form utility functions in `src/lib/formUtils.ts` or similar
  - Include number formatting functions that can be shared across components
  - Example structure:

  ```typescript
  // src/lib/formUtils.ts
  export const formatNumber = (value: string): string => {
    const cleaned = value.replace(/[^\d.]/g, "")
    const parts = cleaned.split(".")
    const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",")
    return parts.length > 1 ? `${integerPart}.${parts[1]}` : integerPart
  }

  export const parseNumber = (value: string): string => {
    return value.replace(/,/g, "")
  }
  ```

- Example structure for other utilities:

  ```typescript
  // src/lib/resource.ts
  interface Resource {
    id: string;
    name: string;
  }

  export const mockResources: Resource[] = [...];

  export function getResourceById(id: string): Resource | undefined {
    return mockResources.find(r => r.id === id);
  }
  ```

### 11. Component Interaction Patterns

- When components need to navigate, pass navigation handlers or use Next.js router directly
- For clickable cards that contain action buttons:
  - Make the card itself a Link component
  - Use event handlers with `e.stopPropagation()` for action buttons inside
  - Use `router.push()` for programmatic navigation in nested buttons
- Always provide proper TypeScript types for event handlers:
  ```typescript
  const handleClick = (e: React.MouseEvent<HTMLButtonElement>): void => {
    e.preventDefault()
    e.stopPropagation()
    // handler logic
  }
  ```

### 12. Form Development Standards

- **ALWAYS use Material UI form components** (TextField, Select, FormControl, etc.)
- Forms MUST be right-to-left (RTL) aligned for Persian content
- Use SCSS modules to style form fields, NOT inline `sx` props
- **RTL Form Styling Requirements:**
  - Labels MUST be positioned on the right side
  - Input text MUST be right-aligned
  - Placeholders MUST be right-aligned
  - Use global CSS selectors to override Material UI defaults:
    ```scss
    .field {
      :global(.MuiInputLabel-root) {
        right: 26px !important;
        left: auto !important;
        transform-origin: top right !important;
      }
      :global(.MuiInputLabel-shrink) {
        transform: translate(-14px, -9px) scale(0.75) !important;
        right: 0 !important;
      }
      :global(.MuiInputBase-input) {
        text-align: right !important;
        direction: rtl !important;
        padding-right: 14px !important;
        padding-left: 14px !important;
      }
      :global(.MuiSelect-select) {
        text-align: right !important;
        direction: rtl !important;
      }
      :global(.MuiSelect-icon) {
        right: auto !important;
        left: 7px !important;
      }
    }
    ```
- **Number Formatting:**
  - For numeric input fields (prices, quantities, etc.), implement number formatting with commas
  - Store numeric values WITHOUT commas in state
  - Display formatted values WITH commas in the UI
  - Create utility functions for formatting:

    ```typescript
    const formatNumber = (value: string): string => {
      const cleaned = value.replace(/[^\d.]/g, "")
      const parts = cleaned.split(".")
      const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",")
      return parts.length > 1 ? `${integerPart}.${parts[1]}` : integerPart
    }

    const parseNumber = (value: string): string => {
      return value.replace(/,/g, "")
    }
    ```

  - Use separate handlers for numeric fields:
    ```typescript
    const handleNumberChange =
      (field: string) => (e: React.ChangeEvent<HTMLInputElement>) => {
        const cleaned = parseNumber(e.target.value)
        setFormData((prev) => ({ ...prev, [field]: cleaned }))
      }
    ```
  - Display formatted values: `value={formatNumber(formData.price)}`

- **Conditional Form Fields:**
  - When form fields change based on user selection (e.g., role-based forms), use conditional rendering
  - Keep all possible form data in a single state object
  - Use clear conditional blocks for different form variants
  - Example structure:
    ```typescript
    {formData.role === "seller" && (
      // Seller-specific fields
    )}
    {formData.role === "buyer" && (
      // Buyer-specific fields
    )}
    ```
- **Form State Management:**
  - Use React useState for form state management
  - Group related fields in the state object
  - Use consistent naming: `handleChange` for text fields, `handleSelectChange` for dropdowns, `handleNumberChange` for numeric fields
  - Always provide proper TypeScript types for handlers
- **Currency and Number Display:**
  - Use Persian currency (تومان) instead of dollar signs for Iranian market
  - Display currency symbol as endAdornment in TextField InputProps
  - Format numbers with Persian/Arabic numerals when appropriate

## File Naming Conventions

- Components: `ComponentName.tsx` (with types defined at the top)
- Utilities: `utilityName.ts`
- Styles: `ComponentName.module.scss` in `styles/` subdirectory within component folder
- Data/Utilities: `resourceName.ts` in `src/lib/` directory
- **Do NOT create** `types.ts` or `index.ts` files - keep component structure simple

## Import Organization

- Group imports: React/Next.js → Third-party → Local components → Types → Styles
- Use absolute imports with `@/` prefix when available

## Example Component Template

```typescript
// ComponentName.tsx
"use client"; // Only if client-side features are needed

import { Box } from "@mui/material";
import styles from "./styles/ComponentName.module.scss";

interface ComponentNameProps {
  prop1: string;
  prop2: number;
  optionalProp?: boolean;
}

export default function ComponentName({ prop1, prop2 }: ComponentNameProps) {
  // Component implementation following Material Design principles
  return (
    <Box className={styles.container}>
      {/* JSX with Material Design components */}
    </Box>
  );
}
```

```scss
// styles/ComponentName.module.scss
.container {
  padding: 16px;
  margin: 8px;
  color: var(--color-text-primary);

  @media (max-width: 768px) {
    padding: 12px;
  }
}
```

**Note:** For simple components without props, you can omit the props interface entirely:

```typescript
// SimpleComponent.tsx
import { Box } from "@mui/material";
import styles from "./styles/SimpleComponent.module.scss";

export default function SimpleComponent() {
  return <Box className={styles.container}>Content</Box>;
}
```

## Form Component Example

```typescript
// FormComponent.tsx
"use client";

import React, { useState } from "react";
import {
  Box,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Button,
} from "@mui/material";
import styles from "./styles/FormComponent.module.scss";

export default function FormComponent() {
  const [formData, setFormData] = useState({
    name: "",
    role: "seller",
    price: "0",
    quantity: "1",
  });

  const formatNumber = (value: string): string => {
    const cleaned = value.replace(/[^\d.]/g, "");
    const parts = cleaned.split(".");
    const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return parts.length > 1 ? `${integerPart}.${parts[1]}` : integerPart;
  };

  const parseNumber = (value: string): string => {
    return value.replace(/,/g, "");
  };

  const handleChange = (field: string) => (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    setFormData((prev) => ({ ...prev, [field]: e.target.value }));
  };

  const handleSelectChange = (field: string) => (
    e: { target: { value: unknown } }
  ) => {
    setFormData((prev) => ({
      ...prev,
      [field]: e.target.value as string,
    }));
  };

  const handleNumberChange = (field: string) => (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const cleaned = parseNumber(e.target.value);
    setFormData((prev) => ({ ...prev, [field]: cleaned }));
  };

  return (
    <Box className={styles.container}>
      <TextField
        label="نام"
        value={formData.name}
        onChange={handleChange("name")}
        fullWidth
        className={styles.field}
        variant="outlined"
      />

      <FormControl fullWidth className={styles.field}>
        <InputLabel>نقش</InputLabel>
        <Select
          value={formData.role}
          onChange={handleSelectChange("role")}
          label="نقش"
        >
          <MenuItem value="seller">فروشنده</MenuItem>
          <MenuItem value="buyer">خریدار</MenuItem>
        </Select>
      </FormControl>

      <TextField
        label="قیمت (تومان)"
        value={formatNumber(formData.price)}
        onChange={handleNumberChange("price")}
        fullWidth
        className={styles.field}
        variant="outlined"
        InputProps={{
          endAdornment: <span style={{ marginLeft: 8 }}>تومان</span>,
        }}
      />

      <TextField
        label="تعداد"
        value={formatNumber(formData.quantity)}
        onChange={handleNumberChange("quantity")}
        fullWidth
        className={styles.field}
        variant="outlined"
      />
    </Box>
  );
}
```

```scss
// styles/FormComponent.module.scss
.container {
  padding: 32px;
  background: #ffffff;
  border-radius: 16px;
}

.field {
  margin-bottom: 24px !important;

  &:last-child {
    margin-bottom: 0 !important;
  }

  // RTL styling for Material UI fields
  :global(.MuiInputLabel-root) {
    right: 26px !important;
    left: auto !important;
    transform-origin: top right !important;
  }

  :global(.MuiInputLabel-shrink) {
    transform: translate(-14px, -9px) scale(0.75) !important;
    right: 0 !important;
  }

  :global(.MuiInputBase-input) {
    text-align: right !important;
    direction: rtl !important;
    padding-right: 14px !important;
    padding-left: 14px !important;
  }

  :global(.MuiSelect-select) {
    text-align: right !important;
    direction: rtl !important;
  }

  :global(.MuiSelect-icon) {
    right: auto !important;
    left: 7px !important;
  }
}
```
